open Conex_result
open Conex_core
open Conex_resource

(* to be called by opam (see http://opam.ocaml.org/doc/2.0/Manual.html#configfield-repository-validation-command, https://github.com/ocaml/opam/pull/2754/files#diff-5f9ccd1bb288197c5cf2b18366a73363R312):

%{quorum}% - a non-negative integer (--quorum)
%{anchors}% - list of digests, separated by "," (--trust-anchors -- to be used in full verification)
%{root}% - the repository root (--repository)

(we need --strict and --no-strict [initially default])

two modes of operation (%{incremental}% will just be "true" or "false"):

-full
%{dir}% is only defined for a full update, and is the dir to verify (--dir)

-incremental
%{patch}% - path to a patch (to be applied with -p1, generated by diff -ruaN dir1 dir2) (--patch)

exit code success = 0, failure otherwise

example:

repository-validation-command: [
   "conex" "--root" "%{root}%" "--trust-anchors" "%{anchors}%" "--patch" "%{patch}%"
]

> cat conex
#!/bin/bash -ue
echo "$*"
true

 *)

open Conex_common

let out = Format.std_formatter

let debug = false

let strict = false

let maybe_exit () = if strict then exit 1

(*
let verify_complete_repository directory trust =
  (* a) load trust anchors and janitors *)
  let p = Conex_provider.fs_ro_provider directory in
  let r = Conex_repository.repository p in
  let r = load_anchors_janitors r out debug maybe_exit trust in
  (* b) load all other identities [can also be teams!] *)
  let r =
    S.fold (load_id out debug maybe_exit)
      (S.diff (Conex_repository.ids r)
         (match Conex_repository.find_team r "janitors" with None -> S.empty | Some s -> s)) r
  in
  (* c) for each package: read & verify authorisation, releases, checksums *)
  S.iter (fun name ->
      match Conex_repository.read_authorisation r name with
      | Error e -> Conex_repository.pp_r_err out e ; maybe_exit ()
      | Ok auth -> match Conex_repository.verify_authorisation r auth with
        | Error e -> Conex_repository.pp_error out e ; maybe_exit ()
        | Ok ok -> if debug then Conex_repository.pp_ok out ok ;
          match Conex_repository.read_releases r name with
          | Error e -> Conex_repository.pp_r_err out e ; maybe_exit ()
          | Ok rel ->
            let good = ref true in
            (match Conex_repository.verify_releases r auth rel with
             | Error e -> Conex_repository.pp_error out e ; good := false ; maybe_exit ()
             | Ok ok -> if debug then Conex_repository.pp_ok out ok) ;
            S.iter (fun rname ->
                match Conex_repository.read_checksum r rname with
                | Error e -> Conex_repository.pp_r_err out e ; good := false ; maybe_exit ()
                | Ok cs -> match Conex_repository.verify_checksum r auth rel cs with
                  | Error e -> Conex_repository.pp_error out e ; good := false ; maybe_exit ()
                  | Ok ok -> if debug then Conex_repository.pp_ok out ok)
              rel.Releases.releases ;
            if !good then Format.fprintf out "verified %a@." pp_name name)
    (Conex_repository.items r) ;
  exit 0
*)
let verify_patch _repo _patch _verbose _strict =
  Ok ()

let verify_full repo _anchors _verbose _strict =
  match Conex_repository.read_team repo "janitors" with
  | _ ->
    (*    load_anchors repo (fun m -> S.mem m anchors) verbose strict *)
    (* read pubkeys *)
    (* filter with anchors *)
    (* add_trusted_key *)
    (* load idx + verify + verify key *)
    (* verify team *)
    (* load rest of janitors + idx + verify *)

    
  Ok ()

let err_to_cmdliner = function
  | Ok () -> `Ok ()
  | Error m -> `Error (false, m)

let verify_it repo quorum anchors incremental dir patch verbose strict =
  let r p =
    let p = Conex_provider.fs_ro_provider p in
    Conex_repository.repository ?quorum p
  in
  err_to_cmdliner
    (match incremental, patch, dir with
     | true, Some p, None ->
       verify_patch (r repo) p verbose strict
     | false, None, Some d ->
       let ta = s_of_list (List.flatten (List.map (Conex_utils.String.cuts ',') anchors)) in
       verify_full (r d) ta verbose strict
     | _ ->
       Error "invalid combination of incremental, patch and dir")

open Cmdliner

let incremental =
  let doc = "do incremental verification" in
  Arg.(value & flag & info [ "incremental" ] ~doc)

let quorum =
  let doc = "Pass the quorum for the repository" in
  Arg.(value & opt (some int) None & info [ "quorum" ] ~doc)

let repo =
    let doc = "Repository base directory" in
    Arg.(value & opt dir "/tmp/conex" & info [ "repository" ] ~doc)

let anchors =
    let doc = "Trust anchors" in
    Arg.(value & opt_all string [] & info [ "trust-anchors" ] ~doc)

let dir =
    let doc = "To be verified directory" in
    Arg.(value & opt (some dir) None & info [ "dir" ] ~doc)

let patch =
    let doc = "To be verified patch file" in
    Arg.(value & opt (some file) None & info [ "patch" ] ~doc)

let verbose =
    let doc = "Increase verbosity" in
    Arg.(value & flag & info [ "verbose" ] ~doc)

let strict =
    let doc = "Strict verification" in
    Arg.(value & flag & info [ "strict" ] ~doc)

let cmd =
  let doc = "Verify a signed repository" in
  let man = [
    `S "DESCRIPTION" ;
    `P "$(tname) verifies a digitally signed repository" ;
    `P "Both an incremental mode (receiving a repository and a patch file, and a full mode are available."
  ]
  in
  Term.(ret (const verify_it $ repo $ quorum $ anchors $ incremental $ dir $ patch $ verbose $ strict)),
  Term.info "conex_verify" ~version:"0.42.0" ~doc ~man

let () = match Term.eval cmd with `Ok () -> exit 0 | _ -> exit 1
