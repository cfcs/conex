open Conex_utils

(* this is the barebones verify with minimal dependencies
   (goal: cmdliner, opam-file-format, Unix, external openssl)
 *)

(* to be called by opam (see http://opam.ocaml.org/doc/2.0/Manual.html#configfield-repository-validation-command, https://github.com/ocaml/opam/pull/2754/files#diff-5f9ccd1bb288197c5cf2b18366a73363R312):

%{quorum}% - a non-negative integer (--quorum)
%{anchors}% - list of digests, separated by "," (--trust-anchors -- to be used in full verification)
%{root}% - the repository root (--repository)

(we need --strict and --no-strict [initially default])

two modes of operation (%{incremental}% will just be "true" or "false"):

-full
%{dir}% is only defined for a full update, and is the dir to verify (--dir)

-incremental
%{patch}% - path to a patch (to be applied with -p1, generated by diff -ruaN dir1 dir2) (--patch)

exit code success = 0, failure otherwise

example:

repository-validation-command: [
   "conex" "--root" "%{root}%" "--trust-anchors" "%{anchors}%" "--patch" "%{patch}%"
]

> cat conex
#!/bin/bash -ue
echo "$*"
true

 *)

let err_to_cmdliner = function
  | Ok _ -> `Ok ()
  | Error m -> `Error (false, m)

module IO = Conex_io

module VERIFY (L : LOGS) (V : Conex_crypto.VERIFY) = struct

  module C = Conex.Make(L)(V)

  let verify_patch io repo patch =
    Conex_unix_persistency.read_file patch >>= C.verify_diff io repo

  let verify_full io repo anchors =
    let valid id (_, digest) =
      if S.mem digest anchors then
        (L.debug (fun m -> m "accepting ta %s" id) ; true)
      else
        (L.debug (fun m -> m "rejecting ta %s" id) ; false)
    in
    C.verify_janitors ~valid io repo >>= fun repo ->
    C.verify_ids io repo >>= fun repo ->
    IO.packages io >>= fun packages ->
    foldS (C.verify_package io) repo packages

  let verify_it repodir quorum anchors incremental dir patch _strict =
    let ta = s_of_list (List.flatten (List.map (Conex_utils.String.cuts ',') anchors)) in
    err_to_cmdliner
      (Conex_openssl.V.check_version () >>= fun () ->
       let repo = Conex_repository.repository ?quorum Conex_openssl.O_V.digest () in
       match incremental, patch, dir with
       | true, Some p, None ->
         Conex_unix_provider.fs_ro_provider repodir >>= fun io ->
         L.debug (fun m -> m "repository %a" Conex_io.pp io) ;
         verify_patch io repo p
       | false, None, Some d ->
         Conex_unix_provider.fs_ro_provider d >>= fun io ->
         L.debug (fun m -> m "repository %a" Conex_io.pp io) ;
         verify_full io repo ta
       | _ -> Error "invalid combination of incremental, patch and dir")

end

let doc = "Verify a signed repository"
and man = [
  `S "DESCRIPTION" ;
  `P "$(tname) verifies a digitally signed repository" ;
  `P "Both an incremental mode (receiving a repository and a patch file, and a full mode are available."
]
