open Conex_result
open Conex_core
open Conex_resource

(* to be called by opam (see http://opam.ocaml.org/doc/2.0/Manual.html#configfield-repository-validation-command, https://github.com/ocaml/opam/pull/2754/files#diff-5f9ccd1bb288197c5cf2b18366a73363R312):

%{quorum}% - a non-negative integer (--quorum)
%{anchors}% - list of digests, separated by "," (--trust-anchors -- to be used in full verification)
%{root}% - the repository root (--repository)

(we need --strict and --no-strict [initially default])

two modes of operation (%{incremental}% will just be "true" or "false"):

-full
%{dir}% is only defined for a full update, and is the dir to verify (--dir)

-incremental
%{patch}% - path to a patch (to be applied with -p1, generated by diff -ruaN dir1 dir2) (--patch)

exit code success = 0, failure otherwise

example:

repository-validation-command: [
   "conex" "--root" "%{root}%" "--trust-anchors" "%{anchors}%" "--patch" "%{patch}%"
]

> cat conex
#!/bin/bash -ue
echo "$*"
true

 *)

let out a b = Format.fprintf Format.std_formatter (a ^^ "\n") b

let load_id id repo =
  if Conex_repository.id_loaded repo id then
    repo
  else
    match Conex_repository.read_id repo id with
    | Error e -> out "%a" Conex_repository.pp_r_err e ; repo
    | Ok (`Id idx) -> begin match Conex_repository.verify_index repo idx with
        | Ok (repo, _, _) -> repo
        | Error e -> out "%a" pp_verification_error e ; repo
      end
    | Ok (`Team t) -> match Conex_repository.verify_team repo t with
      | Ok (repo, _) -> repo
      | Error e -> out "%a" Conex_repository.pp_error e ; repo

let checksum repo auth rel release =
  match Conex_repository.read_checksum repo release with
  | Error e -> out "%a" Conex_repository.pp_r_err e
  | Ok cs -> match Conex_repository.verify_checksum repo auth rel cs with
    | Error e -> out "%a" Conex_repository.pp_error e
    | Ok _ -> ()

let package name repo =
  match Conex_repository.read_authorisation repo name with
  | Error e -> out "while loading %a" Conex_repository.pp_r_err e ; repo
  | Ok a -> match Conex_repository.verify_authorisation repo a with
    | Error e -> out "%a" Conex_repository.pp_error e ; repo
    | Ok (`Quorum _) ->
      (* load + verify authorised ids *)
      let repo = S.fold load_id a.Authorisation.authorised repo in
      (* load + verify releases ++ checksums *)
      match Conex_repository.read_releases repo name with
      | Error e -> out "%a" Conex_repository.pp_r_err e ; repo
      | Ok r -> match Conex_repository.verify_releases repo a r with
        | Error e -> out "%a" Conex_repository.pp_error e ; repo
        | Ok _ -> S.iter (checksum repo a r) r.Releases.releases ; repo

let verify_patch _repo _patch _verbose _strict =
  Ok ()

let verify_full repo anchors _verbose _strict =
  let valid (id, digest) =
    if S.mem digest anchors then
      (Printf.printf "accepting ta %s\n%!" id ; true)
    else
      (Printf.printf "rejecting ta %s\n%!" id ; false)
  in
  match Conex_repository.load_janitors ~valid repo with
  | Ok repo ->
    (* foreach package, read and verify authorisation (may need to load ids), releases, checksums *)
    let _ = S.fold package (Conex_repository.items repo) repo in
    Ok ()
  | Error _ -> Error "couldn't load janitors"

let err_to_cmdliner = function
  | Ok () -> `Ok ()
  | Error m -> `Error (false, m)

let verify_it repo quorum anchors incremental dir patch verbose strict =
  let r p =
    let p = Conex_provider.fs_ro_provider p in
    Conex_repository.repository ?quorum p
  in
  err_to_cmdliner
    (match incremental, patch, dir with
     | true, Some p, None ->
       verify_patch (r repo) p verbose strict
     | false, None, Some d ->
       let ta = s_of_list (List.flatten (List.map (Conex_utils.String.cuts ',') anchors)) in
       verify_full (r d) ta verbose strict
     | _ ->
       Error "invalid combination of incremental, patch and dir")

open Cmdliner

let incremental =
  let doc = "do incremental verification" in
  Arg.(value & flag & info [ "incremental" ] ~doc)

let quorum =
  let doc = "Pass the quorum for the repository" in
  Arg.(value & opt (some int) None & info [ "quorum" ] ~doc)

let repo =
    let doc = "Repository base directory" in
    Arg.(value & opt dir "/tmp/conex" & info [ "repository" ] ~doc)

let anchors =
    let doc = "Trust anchors" in
    Arg.(value & opt_all string [] & info [ "trust-anchors" ] ~doc)

let dir =
    let doc = "To be verified directory" in
    Arg.(value & opt (some dir) None & info [ "dir" ] ~doc)

let patch =
    let doc = "To be verified patch file" in
    Arg.(value & opt (some file) None & info [ "patch" ] ~doc)

let verbose =
    let doc = "Increase verbosity" in
    Arg.(value & flag & info [ "verbose" ] ~doc)

let strict =
    let doc = "Strict verification" in
    Arg.(value & flag & info [ "strict" ] ~doc)

let cmd =
  let doc = "Verify a signed repository" in
  let man = [
    `S "DESCRIPTION" ;
    `P "$(tname) verifies a digitally signed repository" ;
    `P "Both an incremental mode (receiving a repository and a patch file, and a full mode are available."
  ]
  in
  Term.(ret (const verify_it $ repo $ quorum $ anchors $ incremental $ dir $ patch $ verbose $ strict)),
  Term.info "conex_verify" ~version:"0.42.0" ~doc ~man

let () = match Term.eval cmd with `Ok () -> exit 0 | _ -> exit 1
